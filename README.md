# AST стандарт v1.0

Далее все примеры кода будут приведены в си подобном синтаксисе. Он по сути описывает инфиксную запись дерева.

## Числа
Все числа - целые знаковые 32хбитные(aka int)

## Математические операции
Операторы выполняют свою естественную функцию и возвращают целое знаковое 32хбитное число \
Переполнение не является ошибкой исполнения \
Результат вычисления выражения, в котором произошло переполнение не определен \
Деление на ноль - ошибка во время исполнения

* '\+'   - сложение
* '\-'   - вычитание
* '\*'   - умножение
* '\/'   - деление
* '\^'   - возведение в степень
* 'sqrt' - функция квадратного корня, в левом поддереве которой находится единственный аргумент вида 'Expression' (здесь должна быть ссылка на грамматику, но в общем здесь может быть любое выражение с мат. операциями, переменными, input() или функция пользователя)

### Положительные примеры:
```
root_var := sqrt (input() * 3 - x);
```

## Переменные

У всех операторов описанных ниже в левом поддереве может быть только имя переменной
### Создание переменной
tree.txt:
```
(:= (x nil nil)(5 nil nil))
```
source.lang:
```
x := 5;
```
### Созданной переменной присвоить значение
tree.txt:
```
(= (x nil nil)(6 nil nil))
```
source.lang:
```
x = 6;
```

## Условные операторы
### if
Выполняется если условие != 0 \
tree.txt:
```
(if (x nil nil)(:= (y nil nil)(6 nil nil)))
```
source.lang:
```
if (x)
{
  y := 6
}
```
Отрицательные примеры:
```
if (x := 7)
{
  y := 6
}
```

## Циклы
### while
Работает как if но зацикленно \

tree.txt:
```
(; (; (:= ("x" nil nil)
          (6   nil nil)
      )
      (:= ("y" nil nil)
          (0   nil nil)
      )
   (; (while (x nil nil)
          (; (= (y nil nil)(+ (y nil nil)(x nil nil)))
             (= (x nil nil)(- (x nil nil)(1 nil nil)))
          ))
      nil
   )
)
```
source.lang:
```
x := 6
y := 0
while (x)
{
  y = y + x
  x = x - 1
}
```
В данном примере возможно while стоит подцепить к ещё одной ;
Это нужно обсудить

## Служебные ноды
';' - соединяет утверждения ( в том числе if, while)
',' - соединяет аргументы у функции


## Функции
В ast храним название функции в кавычках

Общий вид дерева:
```

(func (, ("name")(params))
      (body ...)
)
(call ("func_name" nil nil)(args nil nil))

```
Конкретные примеры:

```
func_name(a)
{
   x := 3;
}

func_name(3);

(func (, ("func_name" nil nil)
         (, ("a" nil nil)
             nil)
      )
      (; (:= ("x" nil nil)
             (3 nil nil)
         ) nil
      )

(call ("func_name" nil nil)
      (, (3 nil nil) nil)
)
```

main - аналогично func, за исключением того, что оно обозначает точку входа(функцию, с которой начинается выполнение программы)
```
nameOfMainFunctionInLanguage(){}

(main (, ("nameOfMainFunctionInLanguage" nil nil) nil)
      (
        // здесь тело функции
      )
)
```

Три новых оператора

1. func   - объявление функции
2. call   - вызов функции (в левом поддереве название функции, в правом аргументы
3. return - возвращает значение из функции

примеры будут чуть позже

Аргументы разделяются ','
Изменяя аргумент, мы не меняем переменные в исходном месте где была вызвана функция

## Ввод-вывод
### input 
input аналогично ассемблерной инструкции IN. Только значение кладётся в переменную, а не на стек


Положительные примеры:
```
y := 5;
y = input();
x := input();
w := input() * 3;
print(input());
```
Схематичная запись дерева 
```
(:= ("x" nil nil)
    (input nil nil)
)

(= ("y" nil nil)
    (input nil nil)
)
```

Отрицательные примеры:
```
input(z);
input();
print(input(););
```

### print
Положительные примеры:
```
print (x);
print (2);
print (8 * x);
```
Отрицательные примеры:
```
print(print(4));
print(); // возможно стоит обсудить, что пустой принт это перевод строки, но для простоты запрещаем
```



## Положительные примеры кода

В первых версиях без локальных областей видимости, глобально мы стремимся к этому

```
x := 6;
x = 7;
```
```
if (x)
{
  x := 5;
  {
    x := 6;
    // здесь x это 6
    // Компилятор может писать варнинг, но не ошибку
  }
  // здесь x это 5
}
```
## Отрицательные примеры кода

```
x = 6; // ошибка - неизвестное имя переменной

y := 5;
y := 5; // ошибка - повторное объявление переменной
```

## Положительые примеры деревьев

```
("var_name" nil nil)
```
```
(+ (5 nil nil)(* ("abobus" nil nil)(6 nil nil)))
```

## Отрицательные примеры деревьев

```
(var_name nil nil)
```
```
(OP_ADD (5 nil nil)(7 nil nil))
```

## TODO:

* ==
* \>
* <
* else
* break;
* continue;
 
## Обсудить

* Пример с while 
* Нужна ли точка входа? (main) 
* В каком узле(левом или правом) храним 1 аргумент
* Избавиться от nil 
* Аргументы функции в дереве 
* Возвращаемое значение функций 
* print, input
