# AST стандарт v1.0

Далее все примеры кода будут приведены в си подобном синтаксисе. Он по сути описывает инфиксную запись дерева.

## Числа
Все числа - целые знаковые 32хбитные(aka int)

## Математические операции
Операторы выполняют свою естественную функцию и возвращают целое знаковое 32хбитное число \
Переполнение не является ошибкой исполнения \
Результат вычисления выражения, в котором произошло переполнение не определен \
Деление на ноль - ошибка во время исполнения

* '\+' - сложение
* '\-' - вычитание
* '\*' - умножение
* '\/' - деление
* '\^' - возведение в степень

## Переменные

У всех операторов описанных ниже в левом поддереве может быть только имя переменной
### Создание переменной
tree.txt:
```
(:= (x nil nil)(5 nil nil))
```
source.lang:
```
x := 5;
```
### Созданной переменной присвоить значение
tree.txt:
```
(= (x nil nil)(6 nil nil))
```
source.lang:
```
x = 6; 
```

## Условные операторы
### if
Выполняется если условие != 0 \
tree.txt:
```
(if (x nil nil)(:= (y nil nil)(6 nil nil)))
```
source.lang:
```
if (x)
{
  y := 6
}
```
## Циклы
### while
Работает как if но зацикленно \

tree.txt:
```
(; (; (:= ("x" nil nil)
          (6   nil nil)
      )
      (:= ("y" nil nil)
          (0   nil nil)
      )
   (; (while (x nil nil)
          (; (= (y nil nil)(+ (y nil nil)(x nil nil)))
             (= (x nil nil)(- (x nil nil)(1 nil nil)))
          ))
      nil
   )
)
```
source.lang:
```
x := 6
y := 0
while (x)
{
  y = y + x
  x = x - 1
}
```
В данном примере возможно while стоит подцепить к ещё одной ;
Это нужно обсудить

## Служебные ноды
';' - соединяет утверждения ( в том числе if, while)
',' - соединяет аргументы у функции


## Функции
В ast храним название функции в кавычках

Общий вид дерева:
```

(func (, ("name")(params))
      (body ...)
)
(call ("func_name" nil nil)(args nil nil))

```
Конкретные примеры:

```
func_name(a)
{
   x := 3;
}

(func (, ("func_name" nil nil)
         (, ("a" nil nil)
             nil)
      )
      (; (:= ("x" nil nil)
             (3 nil nil)
         ) nil
      )
```

main - аналогично func, за исключением того, что оно обозначает точку входа(функцию, с которой начинается выполнение программы)
```
nameOfMainFunctionInLanguage(){}

(main "nameOfMainFunctionInLanguage" ...)
```

Два новых оператора

1. FUNC - объявление функции
2. CALL - название функции

В левом поддереве - название функции,



Аргументы 

## Положительные примеры кода

```
x := 6;
x = 7;
```
```
if (x)
{
  x := 5;
  {
    x := 6;
    // здесь x это 6
    // Компилятор может писать варнинг, но не ошибку
  }
  // здесь x это 5
}
```
## Отрицательные примеры кода

```
x = 6; // ошибка - неизвестное имя переменной

y := 5;
y := 5; // ошибка - повторное объявление переменной
```

## Положительые примеры деревьев

```
("var_name" nil nil)
```
```
(+ (5 nil nil)(* ("abobus" nil nil)(6 nil nil)))
```

## Отрицательные примеры деревьев

```
(var_name nil nil)
```
```
(OP_ADD (5 nil nil)(7 nil nil))
```

## TODO:

* ==
* \>
* <
* else
* break;
* continue;
 
## Обсудить

* Пример с while 
* Нужна ли точка входа? (main) 
* В каком узле(левом или правом) храним 1 аргумент
* Избавиться от nil 
* Аргументы функции в дереве 
* Возвращаемое значение функций 
* print, input
